# -- coding: utf-8 --
"""Copy of EDA [PART-2].ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wLTycBHSj1mWL2p6BgRooMmLyDmo0agu

Libraries Used:

Conda
---------
-> quickly installs, runs and updates packages and their dependencies

rdkit
------
-> includes a collection of standard cheminformatics functionality for    molecule I/O, substructure searching, chemical reactions, coordinate generation (2D or 3D), fingerprinting, etc.
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from numpy.random import randn, seed
from rdkit import Chem
from rdkit.Chem import Descriptors, Lipinski
from scipy.stats import mannwhitneyu

# from google.colab import files
# import io

# uploaded = files.upload()

# df = pd.read_csv(io.BytesIO(uploaded['bioactivity_data_preprocessed.csv']))
def runEDA():
    
    df = pd.read_csv("medi/Model/bioactivity_data_preprocessed.csv")

    # df

    """Lipinski Descriptors
    -----------------------

    **Drug-likeness* is a qualitative concept used in drug design for how druglike a substance is. To be an effective drug, a substance must be characterized by optimal solubility to both water and fat. We will use **The 5 rules of Lipinski* to get the drug-likeness.

    1. Weight < 500 Da
    2. log(P) < 5, where P = Octanol:Water partitioning
    3. < 5  H-bond donors (-OH)
    4. < 10 H-bond acceptors (-O)
    5. < 5 freely rotating bonds (not originally of the decriptors) 

    Rules 3 and 4 are necessarily saying that if there are too many H-bonds, the molecule would be very hydrophilic which means that it would be very soluble in blood, but then it will not be able to go through the membranes and in particular, the blood-brain barrier. Therefore, the molecule can't be too hydrophilic and too hydrophobic.

    Valium (or, Diazepam) is a molecule which fullfills all the above 5 rules. 

    ![diazepam-2.jpg](attachment:diazepam-2.jpg)

    Why is it bad to have more freely-rotating bonds? Say, we have 2 molecules. One is very floppy and have more rotating bonds. What will happen to it's entropy once it reaches the binding site? It can result in gigantic reduction in entropy if the molecule was free out in water, which means that it will likely not be an efficient binder. The other molecule with lower rotating bonds would have less reduction in entropy, which means that we will likely get a better free energy of binding. Also, it is easier to work with less flexible molecules.

    **However, today no drug passes all the 5 tests stated above. There are either side-effects which are not approved to be brought into the market**

    Import Libraries
    -------------------
    """

    #!pip install rdkit


    """Calculate Descriptors
    -------------------------

    The get_mol function below provides the list of all the molecular structure from the canonical smiles present in the datasets.
    """
    
    df = df[df['molecule_chembl_id'].notna()]
    print(df)

    def get_mol(smiles):
        moldata = []
        for elem in smiles:
            mol = Chem.MolFromSmiles(elem)
            moldata.append(mol)
        return moldata


    # mol = get_mol(df.canonical_smiles)
    # mol[0]

    # Chem

    mol_dict = []

    """The **get_mol(smiles)* function above maps the *smiles to their corresponding molecules which are stored by the rdkit module."""


    def lip_desc(smiles, verbose=False):
        moldata = get_mol(smiles)

        i = 0
        for mol in moldata:
            desc_molWt = Descriptors.MolWt(mol)
            desc_molLogP = Descriptors.MolLogP(mol)
            desc_NumHDonors = Lipinski.NumHDonors(mol)
            desc_NumHAcceptors = Lipinski.NumHAcceptors(mol)

            row = np.array([desc_molWt, desc_molLogP,
                        desc_NumHDonors, desc_NumHAcceptors])

            if i == 0:
                data = row
            else:
                data = np.vstack([data, row])
            i = i+1
        columnNames = ["MW", "LogP", "NumHDonors", "NumHAcceptors"]
        descriptors = pd.DataFrame(data=data, columns=columnNames)

        return descriptors

    print(df.canonical_smiles)
    df_lip = lip_desc(df.canonical_smiles)

    # df_lip.head()

    df_combined = pd.concat([df, df_lip], axis=1)

    # df_combined.head(5)

    """Converting IC50 values to PIC50
    --------------------------------------

    An IC50 measurement tells us the concentration at which a drug is able to inhibit a particular biological process by 50%. For example, if compound A can inhibit 50% of the binding of a ligand to a particular receptor at a concentration of 5 nM, it would have an IC50 value of 5 nM. So then what is a pIC50? It’s simply the negative log of the IC50 value in molar. Watch:

    1. An IC50 of 1 µM is 10^-6 M, which is pIC50 = 6.0
    2. An IC50 of 1 nM is 10^-9 M, which is pIC50 = 9.0

    We use PIC50 because Dose dependent inhibition (or activation) of an enzyme or cell is a logarithmic phenomenon (with regard to compound concentration), so it makes more sense to view the data this way in terms of Ph levels. It makes data more convenient for the readers to understand and compare the potency of different drugs at the same molar levels

    //
    potency is a measure of drug activity expressed in terms of the amount required to produce an effect of given intensity

    The Dose Response Curve
    --------------------------------
    https://www.collaborativedrug.com/why-using-pic50-instead-of-ic50-will-change-your-life/

    The following function **PIC50()** converts standard_values in IC50 values to PIC50 values and adds a corresponding column in the dataframe, deleting the previous standard_value column.
    """


    def PIC50(input):
        PIC50 = []

        for i in input['standard_value_norm']:
            molar = i*(10**-9)  # converts nM to M
            PIC50.append(-np.log10(molar))

        input['PIC50'] = PIC50
        x = input.drop(['standard_value_norm'], axis=1)

        return x


    # df_combined.standard_value.describe()

    # -np.log10((10**-9)*100000000)

    # -np.log10((10**-9)*10000000000)

    """Values greater than 1000,000,000 will be fixed at 100,000,000 otherwise the negative logarithmic values will become negative, as shown above."""


    def norm_values(input):
        norm = []

        for i in input['standard_value']:
            if i > 1000000000:
                i = 1000000000
            norm.append(i)

        input['standard_value_norm'] = norm
        x = input.drop('standard_value', axis=1)

        return x


    df_norm = norm_values(df_combined)
    # df_norm

    # df_norm.standard_value_norm.describe()

    # df_combined.standard_value.describe()

    df_final = PIC50(df_norm)
    # df_final.head(5)

    # df_final.PIC50.describe()


    """*Removing the 'intermediate' bioactivity class*"""

    df_fin2c = df_final[df_final.bioactivity_class != 'intermediate']
    df_fin2c.to_csv('medi/Model/df_final_3c.csv', index=False)
    # df_fin2c.head(10)

    """Chemical Space Analysis with Lipinski Descriptors
    ---------------------------------------------

    More about Chemical Space: https://en.wikipedia.org/wiki/Chemical_space#:~:text=Chemical%20space%20is%20a%20concept,accessible%20and%20available%20to%20researchers

    https://cen.acs.org/physical-chemistry/computational-chemistry/Exploring-chemical-space-AI-take/98/i13

    *Import Library*
    """
    # ........................................
    # # pip install seaborn

    # sns.set(style='ticks')

    # """*Frequency plot of the 2 bioactivity classes*"""

    # plt.figure(figsize=(5.5, 5.5))

    # sns.countplot(x='bioactivity_class', data=df_fin2c, edgecolor='black')

    # plt.xlabel('Bioactivity Class', fontsize=14, fontweight='bold')
    # plt.ylabel('Frequency', fontsize=14, fontweight='bold')

    # plt.savefig('plot_bioactivity_class.pdf')

    # ...........................................

    """*Scatter plot of MW vs LogP*

    The 2 classes are evidently spanning similar chemical spaces
    """

    # plt.figure(figsize=(5.5, 5.5))

    # sns.scatterplot(x='MW', y='LogP', data=df_fin2c, hue='bioactivity_class',
    #                 size='PIC50', edgecolor='black', alpha=0.7)

    # plt.xlabel('MW', fontsize=14, fontweight='bold')
    # plt.ylabel('LogP', fontsize=14, fontweight='bold')
    # plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0)
    # plt.savefig('plot_MW_vs_LogP.pdf')

    """Box Plots
    -----------

    *pIC50 value*
    """

    # plt.figure(figsize=(5.5, 5.5))

    # sns.boxplot(x='bioactivity_class', y='PIC50', data=df_fin2c)

    # plt.xlabel('Bioactivity class', fontsize=14, fontweight='bold')
    # plt.ylabel('pIC50', fontsize=14, fontweight='bold')

    # plt.savefig('plot_pic50.pdf')

    """*Statistical Analysis | Mann-Whitney U Test*

    Man-Whitney U Test is a statistical test which is used to determine whether 2 population samples are different or are the same.

    Reference: https://www.youtube.com/watch?v=Twk6lBhBl88
    """


    def man_whit_test(descriptor, verbose=False):

        seed(1)

        selection = [descriptor, 'bioactivity_class']
        df = df_fin2c[selection]
        active = df[df.bioactivity_class == 'active']
        # get pic50 values of 'active' molecules
        active = active[descriptor]

        selection = [descriptor, 'bioactivity_class']
        df = df_fin2c[selection]
        inactive = df[df.bioactivity_class == 'inactive']
        # get pic50 values of 'inactive' molecules
        inactive = inactive[descriptor]

        # compare samples
        stat, p = mannwhitneyu(active, inactive)

        alpha = 0.05
        if p > alpha:
            interpret = 'Same Distribution (fail to reject H0)'
        else:
            interpret = 'Different Distribution (reject H0)'

        results = pd.DataFrame({'Descriptor': descriptor,
                            'Statistics': stat,
                                'p': p,
                                'alpha': alpha,
                                'Interpretation': interpret}, index=[0])
        filename = 'manwhitneyu_' + descriptor + '.csv'
        results.to_csv('medi/Model/'+filename)

        return results


    # pip install scipy

    man_PIC50 = man_whit_test('PIC50')

    # """*MW*"""

    # plt.figure(figsize=(5.5, 5.5))

    # sns.boxplot(x='bioactivity_class', y='MW', data=df_fin2c)

    # plt.xlabel('Bioactivity Class', fontsize=14, fontweight='bold')
    # plt.ylabel('MW', fontsize=14, fontweight='bold')

    # plt.savefig('plot_MW.pdf')

    man_mw = man_whit_test('MW')

    # """*LogP*"""

    # plt.figure(figsize=(5.5, 5.5))

    # sns.boxplot(x='bioactivity_class', y='LogP', data=df_fin2c)

    # plt.xlabel('Bioactivity Class', fontsize=14, fontweight='bold')
    # plt.ylabel('LogP', fontsize=14, fontweight='bold')

    # plt.savefig('plot_logP.pdf')

    man_logp = man_whit_test('LogP')

    # """*NumHDonors*"""

    # plt.figure(figsize=(5.5, 5.5))

    # sns.boxplot(x='bioactivity_class', y='NumHDonors', data=df_fin2c)

    # plt.xlabel('Bioactivity class', fontsize=14, fontweight='bold')
    # plt.ylabel('NumHDonors', fontsize=14, fontweight='bold')

    # plt.savefig('plot_NumHDonors.pdf')

    man_hd = man_whit_test('NumHDonors')

    # """*NumHAcceptors*"""

    # plt.figure(figsize=(5.5, 5.5))

    # sns.boxplot(x='bioactivity_class', y='NumHAcceptors', data=df_fin2c)

    # plt.xlabel('Bioactivity class', fontsize=14, fontweight='bold')
    # plt.ylabel('NumHAcceptors', fontsize=14, fontweight='bold')

    # plt.savefig('plot_NumHAcceptors.pdf')

    man_ha = man_whit_test('NumHAcceptors')

    """Analysis Interpretation
    --------------------------

    *Box Plots*

    *pIC50 values*

    Taking a look at pIC50 values, the actives and inactives displayed statistically significant difference, which is to be expected since threshold values (IC50 < 1,000 nM = Actives while IC50 > 10,000 nM = Inactives, corresponding to pIC50 > 6 = Actives and pIC50 < 5 = Inactives) were used to define actives and inactives.

    *Lipinski's descriptors*

    Of the 4 Lipinski's descriptors (MW, LogP, NumHDonors and NumHAcceptors), only LogP exhibited no difference between the actives and inactives while the other 3 descriptors (MW, NumHDonors and NumHAcceptors) shows statistically significant difference between actives and inactives.

    *Save results in a ZIP file*
    ------------------------------
    """